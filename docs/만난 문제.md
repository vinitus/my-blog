1. use 훅 문제

리액트 팀은 use라는 훅을 만들었고, 이를 사용할 수 있었다. 그래서 이를 활용하고자 MarkdownForm.tsx를 다음과 같이 하려고 했었다.

```tsx
'use client';

...
  useEffect(() => {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }, [filename]);
...
```

근데 자꾸 브라우저가 멈췄다.. 개발자도구까지도 멈춰서 새로 로딩하는 것도 처음봤음..

![image](https://github.com/vinitus/my-blog/assets/97886013/
9e1438a7-fe05-4748-bcf1-319cd88673b2)

![image](https://github.com/vinitus/my-blog/assets/97886013/8df9d5fc-af6b-4ba4-b6cf-d08895c5401f)

그래서 계속 생각해보니까, 훅 안에서 사용해서 문제이지 않을까? 라고 생각하게 되었다.

```tsx
...
  if (!markdown) {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }
...
```

이렇게 하니까 잘 작동한다. 훅 안에서 사용해봤던 이유중 하나는, 어떤 함수 안에서 사용할 수 있어서 였다. useEffect에 들어가는 익명 함수도 결국 함수니까 될 줄 알았는데 안되던 것이다.

2. layout에 병렬 라우트를 활용하여 컴포넌트의 복잡성 줄이기

nextjs를 정리하다가 발견했던 Parallel Routes 기능이다.

![image](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-cinematic-universe.png&w=1920&q=75&dpl=dpl_29CGhHah8jnx2XznJC26HUXVhuoN)
출처:[https://nextjs.org/docs/app/building-your-application/routing/parallel-routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)

이렇게 좌측은 Markdown을 입력할 textarea태그로 하고 싶었고, 우측은 preview로 하고 싶어서 바로 적용했다.

```tsx
// app/markdown/[filename]/layout.tsx

export default function MarkdownSegmentLayout(props: { editor: React.ReactNode; previewer: React.ReactNode }) {
  return (
    <div className='w-full'>
      {props.editor}
      {props.previewer}
    </div>
  );
}
```

문제는 이 editor와 previewer 사이에 읽어온 마크다운 파일을 상태로써 공유해야한다는 것이다. editor의 마크다운 내용이 변했는데, previewer의 HTML들은 변하지 않으면 안되니까 ㅋㅋ

더 큰 문제는, layout의 병렬 라우팅이 작동하는 방식에서 온다. props로 넘어오는 것이다..

아마 이 layout 컴포넌트가 선언되는 것은 다음과 같은 React 코드일 것 같다.

```tsx
...
  <MarkdownSegmentLayout editor={<EditorCompoent />} previewer={<PreviewerComponent />} />
...
```

문제는 이 코드가 숨겨져 있다. props에 들어가는 두개의 컴포넌트에 어떤 props를 직접 넘겨줄 수 없다. 그럼 이제 `MarkdownSegmentLayout`의 props 렌더링 구조가 문제가 된다.

ReactNode로써 넘어온 것이다. 이는 children의 작동방식과 같으며, 이렇게 `{props.editor}` 같이 렌더링하는 것은 마치 children props를 렌더링하는 것과 유사하다.

이제야 자세히 본 것인데, import 해온 컴포넌트와 props로 온 컴포넌트와 컴포넌트에서 안에서 선언한 JSX는 다르다.

```tsx
const aaa: React.JSX.Element
const aaa = <div>HI</div>;

 (alias) function MarkdownPreview({ markdownContent }: {
    markdownContent: string;
}): React.JSX.Element
import MarkdownPreview from '@/components/MarkdownPreview';

(parameter) children: ReactNode
export default function RootLayout({ children }) {
  ...
}
```

컴포넌트 안에서 만든 JSX 구문은 import 해온 컴포넌트와는 다르게, 일반적인 값이다.
반면에 import한 컴포넌트는 함수이다.

이를 통해서 우리가 JSX에서 사용하고 있는 중괄호 `{}`는 결국 ReactNode만을 위한 것이다.

```tsx
export default function TestComponent() {
  return (
    ...
    // error: 'void' 형식은 'ReactNode' 형식에 할당할 수 없습니다.ts(2322)
    {console.log(1)}
    ...
  )
}
```

컴포넌트는 당연하게도 함수이며, 이 함수의 결과는 React.JSX.Element이다. ReactNode는 실제로 console.log로 봤을 때 굉장히 유사하다. 아마도 ReactNode는 다양한 리액트 트리의 노드를 가르키는 듯하다.

```tsx
{
  '$$typeof': Symbol(react.element),
  type: [Function (anonymous)],
  key: null,
  ref: null,
  props: {
    ...
  },
  _owner: null,
  _store: {}
}
{
  '$$typeof': Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: { children: 'HI' },
  _owner: null,
  _store: {}
}
```

다시 돌아와서, 이러한 이유로 인해 ReactNode는 결국 이미 만들어진 값이며, 이에 props를 추가하는 것은 불가능하다. 그러면 cloneElement를 사용할 수 있지 않을까 생각해봤는데, 결국 cloneElement도 이미 평가된 컴포넌트의 element를 복사하는 것에 불과하기에 사용할 수 없다.

병렬 라우팅 좋은 기능이지만, 더 복잡한 로직에 있어서는 맞지는 않는 듯하다. UI를 위한 라우팅이라고 생각한다.

3. editor와 previewer의 로딩 순서

그렇다면 하나의 컴포넌트 안에서 editor와 previewer 컴포넌트를 불러와야 했다. UI/UX적인 측면에서 생각해보면, 두가지 시나리오가 있다.

1. 에디터만 키는 사람
2. 에디터와 미리보기를 둘 다 켜두는 사람

미리보기에 있는 의존성 그래프를 생각해보면 번들 사이즈가 클 것이다. -> 에디터 컴포넌트가 렌더링된 후에, 미리보기 컴포넌트가 나와야 한다.
아무리봐도 병렬 컴포넌트가 적합하다고 생각되는데 ㅋㅋ 이렇게 된다면 직접 Suspense 컴포넌트를 활용해야할 것 같고, lazyloading을 사용해야할 것 같다.

1. 우선 page.tsx는 순수하게 서버컴포넌트로써 서버의 데이터를 가져오기 위한 컴포넌트로 동작시킨다.
2. Markdown 컴포넌트에 props로 마크다운 데이터를 넘기고, Markdown 컴포넌트는 editor와 previewer 컴포넌트에 상태를 총관리하는 컴포넌트로 만든다.

우선 최적화는 나중으로 하기로 했다.

```tsx
// page.tsx
import Markdown from '@/components/Markdown';
import loadMarkdown from '@/utils/loadMarkdown';

export default async function MarkdownEditor({ params }: { params: { filename: string } }) {
  const { filename } = params;
  const decodedFilename = decodeURIComponent(filename);
  const markdownContent = await loadMarkdown(decodedFilename);
  const markdownDataObj = {
    markdownContent,
    filename,
  };

  return (
    <>
      <Markdown markdownDataObj={markdownDataObj} />
    </>
  );
}
```

이 컴포넌트는 이제 서버에서 데이터를 fetching하는 서버 컴포넌트로써만 작동한다.

```tsx
//Markdown.tsx
'use client';

import { useState } from 'react';
import MarkdownForm from './MarkdownForm';
import MarkdownPreview from './MarkdownPreview';

export default function Markdown({
  markdownDataObj,
}: {
  markdownDataObj: {
    markdownContent: string;
    filename: string;
  };
}) {
  const { markdownContent, filename } = markdownDataObj;
  const [markdown, setMarkdown] = useState(markdownContent);

  return (
    <div className='flex flex-row'>
      <MarkdownForm filename={filename} markdown={markdown} setMarkdown={setMarkdown} />
      <MarkdownPreview markdownContent={markdown} />
    </div>
  );
}
```

이 컴포넌트는 props로 가져온 데이터를 상태로 관리하고, 데이터를 props로 전달하는 역할만 가진다.

```tsx
// MarkdownForm.tsx
'use client';

import { ChangeEvent } from 'react';

interface Props {
  filename: string;
  markdown: string;
  setMarkdown: React.Dispatch<React.SetStateAction<string>>;
}

export default function MarkdownForm({ filename, markdown, setMarkdown }: Props) {
  function markdownChangeHandler(event: ChangeEvent<HTMLTextAreaElement>) {
    setMarkdown(event.target.value);
  }

  return (
    <div className='w-[50%] h-[calc(100vh-195px)]'>
      <h1>{filename + '.md'}</h1>
      <form action='' className='h-full'>
        <textarea name='markdown-editor' id='markdown-editor' defaultValue={markdown} onChange={markdownChangeHandler} className='w-full h-full' />
      </form>
    </div>
  );
}
```

가장 많은 변화가 있었다. `loadData` 함수는 더 이상 사용하지 않는다. 데이터를 가져오는 로직은 전부 제거하고, 이는 렌더링과 입력을 받기위한 컴포넌트로써 작동한다.

4. 백틱 알고리즘 구현

일단 찾기 기능을 만들어야할 듯하다. 찾기를 통해 특정 단어를 찾고, 이를 백틱으로 감싸야할 듯 하다. 디자인은 음 구글 스프레드시트? 아니면 깃허브 마크다운 에디터로 해야겠다.
그 전에 에디터니까, 단순하게 textarea로는 안될 것 같다는 생각이 들었다. 에디터를 구현해야하나? 아니면 가져다 쓸까?

-> 고민해본 결과 slate를 사용하기로 했다.

slate, toast ui, react-quill 등등 돌아다녀봤는데, 결국 slate로 돌아왔다. 문제는 한글에서 onChange의 문제인데.. onChange를 마음대로 바꾸게 되면, 한글 입력에서 문제가 생긴다.

그래서 타협점은 onKeydown이다. 문제는 근데, 내 커서가 가리키고 있는 위치를 알 수 있는 방법을 찾아야한다. 그래야지 모든 배열을 순회하지 않아도 되기 때문?

-> editor의 selection에 접근하면 위치를 알 수 있다.

다음 문제는, slate는 문자열을 배열로써 관리한다는 것이다. 그렇다면 선택지가 두개가 있다.

1. 배열을 순회하며 한줄씩 MarkdownPreview 컴포넌트로 넘기는 방법
2. 배열의 문자열을 합쳐서 MarkdownPreview 컴포넌트로 넘기는 방법

문제는 배열이 길어지게 된다면 2번은 오래걸릴 것 같으니 1번으로 채택

그러면 이제 이 알고리즘을 어떻게 구현하는가이다. 당장 떠오르는 문제가 있다.

React와 React Native를 어떻게 구분해야할까? 당장 떠오르는 것은 다음과 같다.

React를 찾았는데, 그 뒤로 Native라는 단어가 존재한다면 변경하지 않는 것 -> 근데 이렇게 하려면 모든 개발적인 단어를 예외처리로 해야한다.

그렇지만 가장 효과적인 것 아닐까 싶다.

바꾸기를 원하는 단어와 원하지 않는 단어를 아나의 Object에 담고, include, exclude로 해야겠다.

```typescript
interface FilterObj {
  include: string[];
  exclude: string[];
}

const filterObj: FilterObj = {
  include: ["React", "Vue", ...],
  exclude: ["spring", "Spring Boot", ...],
}
```

5. Slate의 한글과 관련된 문제

우선 줄바꿈에 대한 처리를 해야했다. markdown 파일을 읽어오면 \r, \n같은 이스케이프시퀀스를 구분해야했다. 그래서 `transformToSlateValue`라는 함수를 만들어서 여기서 마크다운 파일을 `\n`을 기반으로 배열로 만들고, slate에서 사용하는 배열의 형태로 만들었다.

첫번째로 개행문자를 기반으로 했는데, slate의 editor에 `\r`를 문자로 인식하지 않아서 줄바꿈 처리를 하지 못했다. 그래서 `\r`에 스페이스바를 통한 공백을 강제로 주었다.

그런데, 이제 스페이스바를 다시 인식해서 ㅋㅋ 입력에 문제가 발생했다. 이걸 없애고자 이번에는 `\r`을 `\r\n`으로 시도했는데, 이번에는 줄바꿈이 두번씩 일어나고, 하나의 태그가 두 줄을 차지하는 현상이 발생했다.

그리고 또다른 문제는, `\r`을 HTML이 어떻게 인식하는지는 몰라도, 줄의 끝에서 오른쪽을 누르면 알 수 없는 공간으로 이동했다..

그래서 `\r`을 아예 안쓰면 되는데, 가장 큰 문제가 있다.

바로 새로운 줄에서 한글을 붙여쓰고 입력창 밖을 누르면 마지막 글자가 두번 입력되었다.

크롬 기준이기도 하고, 여러곳 찾아봤는데 IME 문제라고 한다. 근데 솔직히 말해서 이건 slate가 글자를 처리하는 방식의 문제라고 생각했다.

그래서 slate의 github로 가서 이것저것 찾아본 결과,

1. Slate 컴포넌트의 onChange props는 Slate가 만든 change 이벤트가 발생한 후 실행되는 함수였다.
2. focus 이벤트도 사용한다.
3. 결정적으로, beforeInput을 사용한다.

beforeInput을 console.log로 찍어보니깐, 한글이 쳐지는 동안 이 이벤트 리스너의 event.data에 내가 치고 있는 데이터가 담겼다.

이게 무슨말이냐하면, `읽`이라는 글자를 칠 때, `ㅇ`, `ㅣ`, `ㄹ`, `ㄱ`라는 4개의 입력을 해야한다. beforeInput은 이를 감지하고 있으나, Slate가 설정한 beforeInput이벤트는 다르게 작동하는 듯 했다.

그래서 에디터를 간단하게 새로 만들기로 했다...

-> 집가면서 생각해보니깐, textarea가 아닐 이유가 없다 ㅋㅋㅋ

나의 2일은 어디로 간거임..

6. markdown 프리뷰 문제

원래대로 되돌리니까, 다시 마크다운 프리뷰가 줄바꿈이 되지 않는 것을 해결해야했다.

우선 가장 먼저 시도해볼 것은 문자열을 `\n`을 기준으로 배열로 잘라서, 비어있는 요소면 br이던 빈 div던 바꿔야함

```tsx
export default function Markdown({ markdownDataObj }: { markdownDataObj: { markdownContent: string; filename: string } }) {
  const { markdownContent, filename } = markdownDataObj;
  const [markdown, setMarkdown] = useState(markdownContent);
  const splitedMarkdown = markdown.split('\n');

  return (
    <div className='flex flex-row'>
      <MarkdownForm filename={filename} markdown={markdown} setMarkdown={setMarkdown} />
      <div className='w-[50%] flex flex-col'>
        {splitedMarkdown.map((line, idx) => {
          return line === '\r' || !line ? <span className='h-6' key={idx} /> : <MarkdownPreview markdownContent={line} key={idx} />;
        })}
      </div>
    </div>
  );
}
```

이렇게 했는데.. 문제가 발생했다. 내가 생각하는 마크다운과 사람들이 봐왔던 마크다운은, 특정 제목에 해당하는 것들이면 띄워져 있어야 한다고 생각한다.

지금 당장은 문제가 없지만, 만약 다음과 같은 마크다운이 존재한다면

```javascript
`
# HI
## HI
`;
```

지금 내 코드에서는 저 둘은 붙어 있을 것이다. 또한,

```javascript
`
# HI


## Hi
`;
```

이런 코드는 서로 멀리 떨어져있을 것이다. 결국 내가 마크다운 파싱을 구현해야함...

-> 생각해보니까 저런 줄바꿈은 깃허브의 마크다운이나 모든 마크다운에서 중요한 것이 아니었음.

엔터 두번이 markdown에서의 줄바꿈이었고, 엔터 한번은 큰 의미를 가지지는 못하는 것이었음..

그래서 react-markdown 라이브러리를 사용하기로 했다.
