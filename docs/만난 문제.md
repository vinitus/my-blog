1. use 훅 문제

리액트 팀은 use라는 훅을 만들었고, 이를 사용할 수 있었다. 그래서 이를 활용하고자 MarkdownForm.tsx를 다음과 같이 하려고 했었다.

```tsx
'use client';

...
  useEffect(() => {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }, [filename]);
...
```

근데 자꾸 브라우저가 멈췄다.. 개발자도구까지도 멈춰서 새로 로딩하는 것도 처음봤음..

![image](https://github.com/vinitus/my-blog/assets/97886013/
9e1438a7-fe05-4748-bcf1-319cd88673b2)

![image](https://github.com/vinitus/my-blog/assets/97886013/8df9d5fc-af6b-4ba4-b6cf-d08895c5401f)

그래서 계속 생각해보니까, 훅 안에서 사용해서 문제이지 않을까? 라고 생각하게 되었다.

```tsx
...
  if (!markdown) {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }
...
```

이렇게 하니까 잘 작동한다. 훅 안에서 사용해봤던 이유중 하나는, 어떤 함수 안에서 사용할 수 있어서 였다. useEffect에 들어가는 익명 함수도 결국 함수니까 될 줄 알았는데 안되던 것이다.

2. layout에 병렬 라우트를 활용하여 컴포넌트의 복잡성 줄이기

nextjs를 정리하다가 발견했던 Parallel Routes 기능이다.

![image](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-cinematic-universe.png&w=1920&q=75&dpl=dpl_29CGhHah8jnx2XznJC26HUXVhuoN)
출처:[https://nextjs.org/docs/app/building-your-application/routing/parallel-routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)

이렇게 좌측은 Markdown을 입력할 textarea태그로 하고 싶었고, 우측은 preview로 하고 싶어서 바로 적용했다.

```tsx
// app/markdown/[filename]/layout.tsx

export default function MarkdownSegmentLayout(props: { editor: React.ReactNode; previewer: React.ReactNode }) {
  return (
    <div className='w-full'>
      {props.editor}
      {props.previewer}
    </div>
  );
}
```

문제는 이 editor와 previewer 사이에 읽어온 마크다운 파일을 상태로써 공유해야한다는 것이다. editor의 마크다운 내용이 변했는데, previewer의 HTML들은 변하지 않으면 안되니까 ㅋㅋ

더 큰 문제는, layout의 병렬 라우팅이 작동하는 방식에서 온다. props로 넘어오는 것이다..

아마 이 layout 컴포넌트가 선언되는 것은 다음과 같은 React 코드일 것 같다.

```tsx
...
  <MarkdownSegmentLayout editor={<EditorCompoent />} previewer={<PreviewerComponent />} />
...
```

문제는 이 코드가 숨겨져 있다. props에 들어가는 두개의 컴포넌트에 어떤 props를 직접 넘겨줄 수 없다. 그럼 이제 `MarkdownSegmentLayout`의 props 렌더링 구조가 문제가 된다.

ReactNode로써 넘어온 것이다. 이는 children의 작동방식과 같으며, 이렇게 `{props.editor}` 같이 렌더링하는 것은 마치 children props를 렌더링하는 것과 유사하다.

이제야 자세히 본 것인데, import 해온 컴포넌트와 props로 온 컴포넌트와 컴포넌트에서 안에서 선언한 JSX는 다르다.

```tsx
const aaa: React.JSX.Element
const aaa = <div>HI</div>;

 (alias) function MarkdownPreview({ markdownContent }: {
    markdownContent: string;
}): React.JSX.Element
import MarkdownPreview from '@/components/MarkdownPreview';

(parameter) children: ReactNode
export default function RootLayout({ children }) {
  ...
}
```

컴포넌트 안에서 만든 JSX 구문은 import 해온 컴포넌트와는 다르게, 일반적인 값이다.
반면에 import한 컴포넌트는 함수이다.

이를 통해서 우리가 JSX에서 사용하고 있는 중괄호 `{}`는 결국 ReactNode만을 위한 것이다.

```tsx
export default function TestComponent() {
  return (
    ...
    // error: 'void' 형식은 'ReactNode' 형식에 할당할 수 없습니다.ts(2322)
    {console.log(1)}
    ...
  )
}
```

컴포넌트는 당연하게도 함수이며, 이 함수의 결과는 React.JSX.Element이다. ReactNode는 실제로 console.log로 봤을 때 굉장히 유사하다. 아마도 ReactNode는 다양한 리액트 트리의 노드를 가르키는 듯하다.

```tsx
{
  '$$typeof': Symbol(react.element),
  type: [Function (anonymous)],
  key: null,
  ref: null,
  props: {
    ...
  },
  _owner: null,
  _store: {}
}
{
  '$$typeof': Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: { children: 'HI' },
  _owner: null,
  _store: {}
}
```

다시 돌아와서, 이러한 이유로 인해 ReactNode는 결국 이미 만들어진 값이며, 이에 props를 추가하는 것은 불가능하다. 그러면 cloneElement를 사용할 수 있지 않을까 생각해봤는데, 결국 cloneElement도 이미 평가된 컴포넌트의 element를 복사하는 것에 불과하기에 사용할 수 없다.

병렬 라우팅 좋은 기능이지만, 더 복잡한 로직에 있어서는 맞지는 않는 듯하다. UI를 위한 라우팅이라고 생각한다.

3. editor와 previewer의 로딩 순서

그렇다면 하나의 컴포넌트 안에서 editor와 previewer 컴포넌트를 불러와야 했다. UI/UX적인 측면에서 생각해보면, 두가지 시나리오가 있다.

1. 에디터만 키는 사람
2. 에디터와 미리보기를 둘 다 켜두는 사람

미리보기에 있는 의존성 그래프를 생각해보면 번들 사이즈가 클 것이다. -> 에디터 컴포넌트가 렌더링된 후에, 미리보기 컴포넌트가 나와야 한다.
아무리봐도 병렬 컴포넌트가 적합하다고 생각되는데 ㅋㅋ 이렇게 된다면 직접 Suspense 컴포넌트를 활용해야할 것 같고, lazyloading을 사용해야할 것 같다.

1. 우선 page.tsx는 순수하게 서버컴포넌트로써 서버의 데이터를 가져오기 위한 컴포넌트로 동작시킨다.
2. Markdown 컴포넌트에 props로 마크다운 데이터를 넘기고, Markdown 컴포넌트는 editor와 previewer 컴포넌트에 상태를 총관리하는 컴포넌트로 만든다.

우선 최적화는 나중으로 하기로 했다.

```tsx
// page.tsx
import Markdown from '@/components/Markdown';
import loadMarkdown from '@/utils/loadMarkdown';

export default async function MarkdownEditor({ params }: { params: { filename: string } }) {
  const { filename } = params;
  const decodedFilename = decodeURIComponent(filename);
  const markdownContent = await loadMarkdown(decodedFilename);
  const markdownDataObj = {
    markdownContent,
    filename,
  };

  return (
    <>
      <Markdown markdownDataObj={markdownDataObj} />
    </>
  );
}
```

이 컴포넌트는 이제 서버에서 데이터를 fetching하는 서버 컴포넌트로써만 작동한다.

```tsx
//Markdown.tsx
'use client';

import { useState } from 'react';
import MarkdownForm from './MarkdownForm';
import MarkdownPreview from './MarkdownPreview';

export default function Markdown({
  markdownDataObj,
}: {
  markdownDataObj: {
    markdownContent: string;
    filename: string;
  };
}) {
  const { markdownContent, filename } = markdownDataObj;
  const [markdown, setMarkdown] = useState(markdownContent);

  return (
    <div className='flex flex-row'>
      <MarkdownForm filename={filename} markdown={markdown} setMarkdown={setMarkdown} />
      <MarkdownPreview markdownContent={markdown} />
    </div>
  );
}
```

이 컴포넌트는 props로 가져온 데이터를 상태로 관리하고, 데이터를 props로 전달하는 역할만 가진다.

```tsx
// MarkdownForm.tsx
'use client';

import { ChangeEvent } from 'react';

interface Props {
  filename: string;
  markdown: string;
  setMarkdown: React.Dispatch<React.SetStateAction<string>>;
}

export default function MarkdownForm({ filename, markdown, setMarkdown }: Props) {
  function markdownChangeHandler(event: ChangeEvent<HTMLTextAreaElement>) {
    setMarkdown(event.target.value);
  }

  return (
    <div className='w-[50%] h-[calc(100vh-195px)]'>
      <h1>{filename + '.md'}</h1>
      <form action='' className='h-full'>
        <textarea name='markdown-editor' id='markdown-editor' defaultValue={markdown} onChange={markdownChangeHandler} className='w-full h-full' />
      </form>
    </div>
  );
}
```

가장 많은 변화가 있었다. `loadData` 함수는 더 이상 사용하지 않는다. 데이터를 가져오는 로직은 전부 제거하고, 이는 렌더링과 입력을 받기위한 컴포넌트로써 작동한다.

4. 백틱 알고리즘 구현

일단 찾기 기능을 만들어야할 듯하다. 찾기를 통해 특정 단어를 찾고, 이를 백틱으로 감싸야할 듯 하다. 디자인은 음 구글 스프레드시트? 아니면 깃허브 마크다운 에디터로 해야겠다.
그 전에 에디터니까, 단순하게 textarea로는 안될 것 같다는 생각이 들었다. 에디터를 구현해야하나? 아니면 가져다 쓸까?

-> 고민해본 결과 slate를 사용하기로 했다.
