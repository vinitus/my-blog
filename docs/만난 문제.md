1. use 훅 문제

리액트 팀은 use라는 훅을 만들었고, 이를 사용할 수 있었다. 그래서 이를 활용하고자 MarkdownForm.tsx를 다음과 같이 하려고 했었다.

```tsx
'use client';

...
  useEffect(() => {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }, [filename]);
...
```

근데 자꾸 브라우저가 멈췄다.. 개발자도구까지도 멈춰서 새로 로딩하는 것도 처음봤음..

![image](https://github.com/vinitus/my-blog/assets/97886013/
9e1438a7-fe05-4748-bcf1-319cd88673b2)

![image](https://github.com/vinitus/my-blog/assets/97886013/8df9d5fc-af6b-4ba4-b6cf-d08895c5401f)

그래서 계속 생각해보니까, 훅 안에서 사용해서 문제이지 않을까? 라고 생각하게 되었다.

```tsx
...
  if (!markdown) {
    const markdownFile = use(loadMarkdown(filename));
    setMarkdown(markdownFile);
  }
...
```

이렇게 하니까 잘 작동한다. 훅 안에서 사용해봤던 이유중 하나는, 어떤 함수 안에서 사용할 수 있어서 였다. useEffect에 들어가는 익명 함수도 결국 함수니까 될 줄 알았는데 안되던 것이다.

2. layout에 병렬 라우트를 활용하여 컴포넌트의 복잡성 줄이기

nextjs를 정리하다가 발견했던 Parallel Routes 기능이다.

![image](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fparallel-routes-cinematic-universe.png&w=1920&q=75&dpl=dpl_29CGhHah8jnx2XznJC26HUXVhuoN)
출처:[https://nextjs.org/docs/app/building-your-application/routing/parallel-routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)

이렇게 좌측은 Markdown을 입력할 textarea태그로 하고 싶었고, 우측은 preview로 하고 싶어서 바로 적용했다.

```tsx
// app/markdown/[filename]/layout.tsx

export default function MarkdownSegmentLayout(props: { editor: React.ReactNode; previewer: React.ReactNode }) {
  return (
    <div className='w-full'>
      {props.editor}
      {props.previewer}
    </div>
  );
}
```

문제는 이 editor와 previewer 사이에 읽어온 마크다운 파일을 상태로써 공유해야한다는 것이다. editor의 마크다운 내용이 변했는데, previewer의 HTML들은 변하지 않으면 안되니까 ㅋㅋ

더 큰 문제는, layout의 병렬 라우팅이 작동하는 방식에서 온다. props로 넘어오는 것이다..

아마 이 layout 컴포넌트가 선언되는 것은 다음과 같은 React 코드일 것 같다.

```tsx
...
  <MarkdownSegmentLayout editor={<EditorCompoent />} previewer={<PreviewerComponent />} />
...
```

문제는 이 코드가 숨겨져 있다. props에 들어가는 두개의 컴포넌트에 어떤 props를 직접 넘겨줄 수 없다. 그럼 이제 `MarkdownSegmentLayout`의 props 렌더링 구조가 문제가 된다.

ReactNode로써 넘어온 것이다. 이는 children의 작동방식과 같으며, 이렇게 `{props.editor}` 같이 렌더링하는 것은 마치 children props를 렌더링하는 것과 유사하다.

이제야 자세히 본 것인데, import 해온 컴포넌트와 props로 온 컴포넌트와 컴포넌트에서 안에서 선언한 JSX는 다르다.

```tsx
const aaa: React.JSX.Element
const aaa = <div>HI</div>;

 (alias) function MarkdownPreview({ markdownContent }: {
    markdownContent: string;
}): React.JSX.Element
import MarkdownPreview from '@/components/MarkdownPreview';

(parameter) children: ReactNode
export default function RootLayout({ children }) {
  ...
}
```

컴포넌트 안에서 만든 JSX 구문은 import 해온 컴포넌트와는 다르게, 일반적인 값이다.
반면에 import한 컴포넌트는 함수이다.

이를 통해서 우리가 JSX에서 사용하고 있는 중괄호 `{}`는 결국 ReactNode만을 위한 것이다.

```tsx
export default function TestComponent() {
  return (
    ...
    // error: 'void' 형식은 'ReactNode' 형식에 할당할 수 없습니다.ts(2322)
    {console.log(1)}
    ...
  )
}
```

컴포넌트는 당연하게도 함수이며, 이 함수의 결과는 React.JSX.Element이다. ReactNode는 실제로 console.log로 봤을 때 굉장히 유사하다. 아마도 ReactNode는 다양한 리액트 트리의 노드를 가르키는 듯하다.

```tsx
{
  '$$typeof': Symbol(react.element),
  type: [Function (anonymous)],
  key: null,
  ref: null,
  props: {
    ...
  },
  _owner: null,
  _store: {}
}
{
  '$$typeof': Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: { children: 'HI' },
  _owner: null,
  _store: {}
}
```

다시 돌아와서, 이러한 이유로 인해 ReactNode는 결국 이미 만들어진 값이며, 이에 props를 추가하는 것은 불가능하다. 그러면 cloneElement를 사용할 수 있지 않을까 생각해봤는데, 결국 cloneElement도 이미 평가된 컴포넌트의 element를 복사하는 것에 불과하기에 사용할 수 없다.

병렬 라우팅 좋은 기능이지만, 더 복잡한 로직에 있어서는 맞지는 않는 듯하다. UI를 위한 라우팅이라고 생각한다.
